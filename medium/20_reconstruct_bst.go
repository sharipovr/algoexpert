package main

import "fmt"

// –ò–Ω—Ç—É–∏—Ü–∏—è:
// –í pre-order –æ–±—Ö–æ–¥–µ –ø–æ—Ä—è–¥–æ–∫:
// –¢–µ–∫—É—â–∏–π —É–∑–µ–ª ‚Üí –õ–µ–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ ‚Üí –ü—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
// –ü–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç ‚Äî —ç—Ç–æ –∫–æ—Ä–µ–Ω—å –¥–µ—Ä–µ–≤–∞
// –î–∞–ª–µ–µ:
// –í—Å—ë, —á—Ç–æ –º–µ–Ω—å—à–µ –∫–æ—Ä–Ω—è ‚Üí –ª–µ–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
// –í—Å—ë, —á—Ç–æ –±–æ–ª—å—à–µ –∫–æ—Ä–Ω—è ‚Üí –ø—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
// –ü—Ä–∏–º–µ—Ä:
// preOrder = [10, 4, 2, 1, 5, 17, 19, 18]
// 10 ‚Äî –∫–æ—Ä–µ–Ω—å
// –í—Å—ë —á—Ç–æ <10 (–¥–æ 17): 4, 2, 1, 5 ‚Üí –ª–µ–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
// –í—Å—ë —á—Ç–æ >10: 17, 19, 18 ‚Üí –ø—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
// üì¶ –ü–ª–∞–Ω:
// –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º –∏–Ω–¥–µ–∫—Å currentIdx, —É–∫–∞–∑—ã–≤–∞—é—â–∏–π –Ω–∞ —Ç–µ–∫—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç –≤ –º–∞—Å—Å–∏–≤–µ
// –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å—Ç—Ä–æ–∏–º –¥–µ—Ä–µ–≤–æ:
// —Ç–µ–∫—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç ‚Üí —Å–æ–∑–¥–∞—ë–º —É–∑–µ–ª
// –≤—Å—ë —á—Ç–æ –º–µ–Ω—å—à–µ ‚Üí –∏–¥—ë—Ç –≤–ª–µ–≤–æ
// –≤—Å—ë —á—Ç–æ –±–æ–ª—å—à–µ ‚Üí –∏–¥—ë—Ç –≤–ø—Ä–∞–≤–æ
// –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞ –∑–∞–¥–∞—ë–º –¥–æ–ø—É—Å—Ç–∏–º—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω minValue, maxValue (–∫–∞–∫ –≤ –∑–∞–¥–∞—á–µ Validate BST)
type BST20 struct {
	Value int

	Left  *BST20
	Right *BST20
}

// –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è ‚Äî –ø—Ä–∏–Ω–∏–º–∞–µ—Ç preorder –º–∞—Å—Å–∏–≤ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ—Ä–µ–Ω—å –¥–µ—Ä–µ–≤–∞
func ReconstructBST(preOrder []int) *BST20 {
	idx := 0
	return helper(preOrder, &idx, -1<<63, 1<<63-1)
}

// –°—Ç—Ä–æ–∏–º –ø–æ–¥–¥–µ—Ä–µ–≤–æ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ (min, max)
func helper(array []int, currentIdx *int, minVal, maxVal int) *BST20 {
	// –ï—Å–ª–∏ –≤—Å—ë –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–æ ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º nil
	if *currentIdx >= len(array) {
		return nil
	}

	currentVal := array[*currentIdx]

	// –ó–Ω–∞—á–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö [minVal, maxVal)
	if currentVal < minVal || currentVal >= maxVal {
		return nil // —Ç–µ–∫—É—â–∏–π —É–∑–µ–ª –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–∑–º–µ—â—ë–Ω –∑–¥–µ—Å—å
	}

	// –°–æ–∑–¥–∞—ë–º —É–∑–µ–ª
	*currentIdx++
	node := &BST20{Value: currentVal}

	// –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å—Ç—Ä–æ–∏–º –ª–µ–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
	node.Left = helper(array, currentIdx, minVal, currentVal)

	// –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ —Å—Ç—Ä–æ–∏–º –ø—Ä–∞–≤–æ–µ –ø–æ–¥–¥–µ—Ä–µ–≤–æ
	node.Right = helper(array, currentIdx, currentVal, maxVal)

	return node
}

func main() {
	values := []int{10, 4, 2, 1, 5, 17, 19, 18}
	root := ReconstructBST(values)

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ in-order –æ–±—Ö–æ–¥–æ–º ‚Äî –¥–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤
	fmt.Println("InOrder:", inOrderTraverse(root, []int{}))
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ö–æ–¥–∞ –¥–µ—Ä–µ–≤–∞ (–¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏)
func inOrderTraverse(tree *BST20, array []int) []int {
	if tree != nil {
		array = inOrderTraverse(tree.Left, array)
		array = append(array, tree.Value)
		array = inOrderTraverse(tree.Right, array)
	}
	return array
}
